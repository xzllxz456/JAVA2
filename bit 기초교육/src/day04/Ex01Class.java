package day04;
// 클래스 컨닝페이퍼
// 1. 객체지향프로그래밍이란?
//    객체지향프로그래밍은 하나의 커다란 프로그램이 작은 프로그램 변수를 만들엇
//    그 작은 프로그램 변수들이 만들어주는 내부적 메시지를 활요한 프로그래밍을
//    객체지향프로그래밍이라고 한다.
//    객체란 단순하게는 클래스 변수를 말한다.
//    즉 우리가 만든 클래스로 변수를 만들거나 혹은 다른 사람이나 자바가 기본적으로
//    제공해주는 클래스로 변수를 만들어서 우리가 쓸 코드의 양을 줄이자
//    가 객체지향이 목표하는 바이다.
// 2. 클래스란?
//    클래스란 하나의 프로그램으로써 일종의 설계도이다.
//    예를 들어서, 티비 설계도가 있으면 그 자체는 티비가 아니지만
//    티비 설계도를 토대로 해서 실제로 티비를 만들면, 우리가 그 티비를 볼 수 있다.
//    그렇다면, 우리가 똑같은 모델의 
//    티비를 만들때마다 설계도를 매번 새로 만들어줘야할까?
//    정답은 아니다!
//    하나의 설계도만 있으면 해당 모델의 티비를 우리가 마음껏 만들어줄 수 있다.
//    
// 3. 클래스의 구조
//    클래스는 필드와 메소드로 이루어져 있다.
//    필드란 해당 클래스의 객체가 가지고 있을 정보의 종류를 정하는 것이다.
//    TV로 예를 들자면, 현재 볼륨, 현재 채널, 제조일, 시리얼 번호 등이 필드가 된다.
//    메소드란 해당 클래스의 객체가 가지고 있는 기능들을 말한다.
//    TV로 예를 들자면 전원 켜기, 전원 끄기, 볼륨 높이기, 채널 내리기 등이 기능이 된다.
//
// 4. 필드
//    필드는 해당 클래스의 객체가 어떤 데이터를 가지고 있을지를 규정한다.
//    근데 해당 필드들이 실제로 값이 저장되는 때는 언제인가?
//    예를 들어 TV 설계도에는 현재 볼륨과 같은 데이터가 실제로 들어가 있는 것이 아니라
//    "어디에 적어라~" 정도가 들어가 있는 것이다.
//    그렇다면 실제로 데이터가 들어가는건 언제인가?
//    설계도로 실물 TV를 만들었을 때 들어가게 된다.
//    클래스와 객체의 필드도 마찬가지이다.
//    클래스의 필드에는 어떤 정보가 들어갈지 그리고 그 정보를 뭐라고 부를지 
//    "선언"만 한다.
//    그 후에 실제 객체를 만들때 해당 필드들이 초기화되서 우리가 비로소
//    사용할 수 있는 단계가 되는 것이다.
//    필드의 선언은 다음과 같이 한다.
//    데이터타입 필드이름;
//    예시: int volume; int channel; String serialNumber;
//
// 5. 메소드
//    메소드란, 해당 클래스의 객체들이 "공통"적으로 가지고 있는 기능을 
//    메소드라고 한다.
//    공통적으로 가지고 있다고 함은, 똑같은 클래스의 객체라면, 그 기능들은
//    똑같은 코드로 실행된다는 뜻이다.
//    예: 똑같은 설계도로 만든 똑같은 모델의 티비들은 볼륨 높이기 코드가 똑같다.
//    메소드는 
//    (리턴할 데이터의 종류) 메소드 이름(파라미터 내용) 으로 이루어져 있다.
//    A. 리턴할 데이터의 종류
//       메소드는 무조건 해당 메소드가 종료될때, 어떤 타입의 데이터를
//       호출된 곳으로 보내줄지를 정해놓아야 한다.
//       예를 들어, 정수 두개를 더해서 보내주는 기능이라면 리턴 타입은 int가 된다.
//       단 호출된 곳으로 아무런 종류의 데이터를 보내주지 않는 다면 리턴 타입은
//       void가 된다.
//       만약 리턴 타입이 void가 아닐 경우에는, 반드시 메소드 어딘가에 
//       return 이라는 예약어를 써서, 해당 리턴 타입과 일치하는 데이터를
//       보내주어야 한다.
//       또한 return은 코드에서 실행 가능할때, 곧장 해당 메소드를 종료 시킨다.
//    B. 메소드 이름: 소문자로 시작하는 동사
//    C. 파라미터 내용
//       파라미터란, 해당 메소드가 실행될때 외부로부터 받아올 값을
//       파라미터라고 한다.
//       예를 들어서, 정수 두개를 더해주는 기능은 외부로부터 정수 두개를 받아와야한다.
//       파라미터의 경우 한국말로는 "매개 변수" 라고도 표현하는데, 
//       괄호 안에 변수처럼 적어놓고, 메소드 내부에서도
//       변수처럼 사용가능하기 때문이다.
//       예시: (int firstNumber, double Average), (String[] args)
//       만약 해당 메소드가 외부로부터 아무런 값도 받아올 필요가 없다면
//       아무런 파라미터가 안들어가도 된다.
//    메소드는 다음과 같이 생겼다.
//    returnType name(parameter) {
//        코드내용
//    }
//    저중에서 맨 첫번째 줄은 메소드의 선언이다.
//    그리고 메소드의 선언 이후에 나오는 { }에 해당 메소드의 기능을 
//    정의해주면 된다.
// 6. 생성자 (Constructor)
//    생성자란, 해당 클래스의 객체가 초기화 될때 필드의 값을 초기화 하거나
//    아니면 추가적인 기본 작업이 필요하다면 생성자가 하게 만들어준다.
//    생성자의 경우 리턴 타입이 존재하지 않고
//    이름은 클래스의 이름과 일치한다.
//    만약 우리가 생성자를 따로 만들어주지 않으면
//    자바가 기본적으로 제공해주는 생성자가
//    객체의 필드값들을 초기화해준다.
//    만약 필드의 데이터타입이 기본형이라면 0으로 초기화한다.
//    만약 필드의 데이터타입이 참조형이라면 null로 초기화한다.
//    자바가 제공해주는 기본 생성자의 경우
//    만약 사용자가 직접 생성자를 만들어주면 더이상 사용이 불가능해진다!
//    또한, 우리가 파라미터가 있는 생성자를 만들어준다면, 더이상
//    파라미터가 없는 생성자는 호출 불가능해지기 때문에
//    만약 두 종류의 생성자가 모두 필요하다면, 둘다 만들어주어야 한다.
// 7. null
//    null이란 참조형 변수에서만 찾아볼수 있는 값이다.
//    더 엄밀하게 말하면 값보다 상태인데
//    "주소값은 부여가 됬으나 해당 주소를 참조하여 실제 필드와 메소드가 있는 공간은
//     초기화가 안되어 사용할 수 없는 상태" 라고 표현 가능하다.
//    null인 상태에선 해당 객체의 필드나 메소드에 "아예" 접근이 불가능하다.
//    즉 객체. 으로 필드나 메소드를 호출할려고 하면
//    NullPointerException이라는 에러가 발생하게 된다!!!
// 8. 메소드 오버로딩
//    메소드 오버로딩이란, 같은 이름의 메소드이지만 파라미터가 달라짐으로써
//    똑같은 이름과 똑같은 기능을 하는 메소드를 여러개 만들어서
//    다양한 파라미터를 다룰 수 있게 만드는 것이다.
//    단, 여기서 주의해야할 저은 파라미터가 달라야 한다는 것이다.
//    퀴즈) 다음중 파라미터가 다른 것은?
//         1. setInfo(String name, int korean, int english, int math)
//         2. setInfo(String ssn, int math, int korean, int english)
//         3. setInfo(String name, int korean, int english)
//         답은 3번
//         만약 2번도 다른거라면
//         setInfo("", 100, 100, 100) 이라고 객체의 메소드를 호출하면
//         몇번 메소드가 호출되어야 하는가?
//         혹은 String ssn = "조재영";
//         setInfo(ssn, 80, 80, 80) 이라고 메소드를 호출하면
//         1번과 2번 중에 어떤게 호출되어야 할까?
//         우리가 모르는걸 자바가 알까....
//    즉 메소드 파라미터가 같은지 다른지를 비교할 때에는
//    파라미터 데이터타입의 순서를 확인하면 된다.
//    예시: setInfo(String, int, int, int)와 setInfo(String, int, int)
//
// 9. 파라미터와 필드의 호출 우선 순위
//    메소드 안에서 같은 이름의 파라미터와 필드가 존재할 시에는
//    기본적으로 파라미터가 호출된다.
//    따라서, 만약 같은 이름의 파라미터와 필드가 존재할 시에는
//    필드를 호출할 때에는 
//    명확하게 "이 객체의 필드" 라는 의미에서
//    앞에 this.을 붙여주어야 한다.
//
// 10. 접근제한자(Access Modifier)
//     접근제한자란, 해당 필드 혹은 메소드가 외부 클래스의 위치에 따라
//     호출이 가능한지 불가능한지를 제한한다.
//     public: 외부 패키지건 내부 패키지건 어디에 있든 무슨 클래스든
//              접근이 가능하다.
//     protected: 내부 패키지의 다른 클래스들은 접근이 가능하지만
//                외부 패키지의 클래스는 해당 클래스를 상속받는 클래스들만
//                접근 가능하다.
//     package: 내부 패키지의 다른 클래스들은 접근이 가능하지만
//              외부 패키지의 모든 클래스들은 접근이 불가능하다.
//              만약 우리가 아무런 접근제한자를 안써주면 패키지 접근 제한자가
//              적용된다. 단 package는 다른 예약어이므로 써주면 오히려 안된다.
//     private: 내부 패키지건 외부 패키지건 다른 클래스면 아예 접근이 불가능하다.
// 접근제한자는 캡슐화 라는 개념때문에 매우 중요해졌다.
// 왜냐면 이제는 더이상 해당 클래스의 객체가 어떤 필드가 있고 어떤 메소드가 있는지
// 전부 공개하는게 아니라
// 모든 필드들은 숨기고
// 메소드들 중에서 외부에서 쓸 메소드들만 public 나머지는 다 숨기는게
// 트렌드가 되었기 때문.

// 하지만 필드를 private으로 하면 더이상 다른 클래스에서 해당 객체의 필드값을
// 직접 접근할 수 없게 되기 때문에 값을 넣거나 뺄때 메소드를 만들어서
// 그 메소드들이 간접적으로 값을 넣고 호출하는 방식으로 만들어 주어야 한다!
// 외부로부터 값을 받아서 필드에 값을 넣는 메소드는 우리가 setter 메소드라고 한다.
// setter 메소드는 다음과 같은 양식을 가진다.
//   public void set필드이름(필드타입 필드이름){
//      this.필드이름 = 필드이름;
//   }
//
// 필드의 값을 호출된 곳으로 보내주는 메소드는 우리가 getter 메소드라고 한다.
// getter 메소드는 다음과 같은 양식을 가진다.
//   public 필드타입 get필드이름(){
//      return 필드이름;
//   }
//
// 11. 상속
//     프로그래밍에서 상속은 부모 클래스가 만들어놓은 메소드를 
//     자식 클래스가 다시 안만들어도 되게, 즉 코드의 재사용성을 높이기 위해서
//     상속을 사용하게 된다.
//     특히 자바 같은 경우에는
//     equals, toString(), 기본 생성자 등을 java.lang.Object 라는
//     클래스에 만들어놓고 자바에 존재하는 모든 클래스가 java.lang.Object를
//     상속받게 만들어놓음으로써 기본적으로 저러한 메소드들을
//     모든 클래스가 사용가능하게 구현해놨다.
//     하지만 java.lang.Object가 미리 구현한 메소드들은 모든 클래스가
//     사용가능하게 만들었기 때문에, 특정 클래스에서 사용할 때에는 오히려
//     우리가 원하지 않는 결과를 받을 수도 있다.
//     특히 equals같은 경우에는 우리가 객체의 비교를 위해서 필드의 저장된
//     값을 비교하고 싶지만, java.lang.Object에 나와있는 equals()는
//     주소값 비교를 하게 구현되어있고, toString()의 경우에는 해당 객체의
//     필드값들이 아니라, 객체의 클래스 위치와 메모리 주소값이 나오게 구현되어있다.
//     따라서, 필요하다면 자식 클래스가 부모 클래스로부터 상속받은 메소드를
//     "재정의" 해야하는데 이러한 재정의를 오버라이드 라고 한다!

// 12. 오버라이드(override)
//     오버라이드란, 부모클래스의 메소드를 자식 클래스가 재정의하는 것을
//     오버라이드라고 한다.
//     오버라이드를 할때는 한가지 주의할 점이 있는데,
//     부모클래스가 메소드를 선언한것과 똑같이 써야한다!!!!
//     예시: java.lang.Object가 equals 메소드를
//     public boolean equals(Object o) 라고 선언했으므로
//     자식클래스도 똑같이 선언해야한다.
public class Ex01Class {
	
}









